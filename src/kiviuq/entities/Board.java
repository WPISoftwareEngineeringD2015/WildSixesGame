package kiviuq.entities;

import java.util.Random;

/**
 * Abstract class that represents a Board. The Board class contains information
 * and functions pertaining to a given game of Sixes Wild. Some of its
 * functionality is delegated to subclasses which provide game specific
 * implementation functions for each variation of Sixes Wild.
 * 
 * @author Evin Ugur
 *
 */
public abstract class Board {

	/**
	 * Represents the Length (in terms of {@link Tile) objects) of a given Sixes
	 * Wild Board.
	 */
	public static final int BOARD_LENGTH = 9;

	/**
	 * Represents the Width (in terms of {@link Tile) objects) of a given Sixes
	 * Wild Board.
	 */
	public static final int BOARD_WIDTH = 9;

	/**
	 * The LevelTemplate which was was likely created in the Level Builder
	 * program
	 */
	LevelTemplate template;

	/**
	 * Name of actual file on disk used to Load/Save LevelTemplate
	 * (templates include highScore information)
	 */
	String name;

	/**
	 * Tiles on the grid. Initialized to {@link Constants#BOARD_LENGTH} x
	 * {@link Constants#BOARD_WIDTH}.
	 */
	Tile[][] grid;

	/** Amount of moves made */
	int movesMade;
	/** Total amount of allowable moves */
	int moveLimit;
	/** Amount of time that's passed */
	int timePassed;
	/** Score for the game */
	int points;
	/** Criteria for earning stars */
	StarCriteria starCriteria;

	/** Sum of the selected Tiles */
	int tileSum;
	/** Number of Tiles that are currently selected */
	int tileCount;
	/**
	 * Represents the kind of Move that is currently being performed on this
	 * Board
	 */
	MoveType moveType = MoveType.Normal;

	/** Stores if the mouse is pressed on this Board */
	boolean isMousePressed;
	/** last x position from selection */
	int lastX = -1;
	/** last y position from selection */
	int lastY = -1;

	/**
	 * Randomization constants generated by constructor based off template
	 * multipliers
	 */
	int r1, r2, r3, r4, r5;
	int m1, m2;
	
	/**
	 * Boolean flag to ensure level is not "won" more than once.
	 */
	boolean winFlag = true;

	/**
	 * This function takes a LevelTemplate and will construct the appropriate
	 * Board object based off of that.
	 * <p>
	 * Since Board is abstract, and its subclasses have no available
	 * constructors, this is the only way to build boards. This is done
	 * partially to discourage people from ever maintaining objects of a Board
	 * subclass. That should only happen when specific code needs to be executed
	 * based on which kind of Board is being dealt with, however most of those
	 * cases are addressable simply by adding and then implementing abstract
	 * methods to this class.
	 * 
	 * @param template
	 *            the {@link LevelTemplate} template for the file.
	 * @return the proper subclass of {@link Board}
	 */
	public static Board MakeBoardFromTemplate(LevelTemplate template, String name) {
		GameMode mode = template.getGameMode();
		switch (mode) {
		case Puzzle:
			return new PuzzleBoard(template, name);
		case Lightning:
			return new LightningBoard(template, name);
		case Release:
			return new ReleaseBoard(template, name);
		case Elimination:
			return new EliminationBoard(template, name);
		default:
			break;
		}
		return null;
	}

	/**
	 * Publicly unaccessible constructor to Board. Super classes invoke this
	 * constructor when they're called from
	 * {@link Board#MakeBoardFromTemplate(LevelTemplate)}.
	 * <p>
	 * This constructor initializes a Board's fields to proper values.
	 * 
	 * @param template
	 *            the LevelTemplate object used for building this Board.
	 */
	protected Board(LevelTemplate template, String name) {
		this.timePassed = 0;
		this.points = 0;
		this.name = name;
		this.setTemplate(template);
		moveLimit = template.moveLimit;
		grid = new Tile[Board.BOARD_LENGTH][Board.BOARD_WIDTH];
		starCriteria = template.getStarCriteria();
		TileType[][] gridTemplate = template.getGridTemplate();

		int pMult = template.probConst;
		r1 = 40 - pMult / 4;
		r2 = 25 - pMult / 10;
		r3 = 15 + pMult / 20;
		r4 = 10 + pMult / 10;
		r5 = 5 + pMult / 10;

		int mMult = template.multConst;
		m1 = 100 - mMult;
		m2 = (mMult * 2) / 3;

		for (int x = 0; x < Board.BOARD_LENGTH; x++) {
			for (int y = 0; y < Board.BOARD_WIDTH; y++) {
				TileType type = gridTemplate[x][y];
				Tile t;
				if (type == TileType.Number)
					t = getNextTile();
				else if (type == TileType.Block) // this will convert the Tile
					// to be a number Tile.
					t = Tile.NewBlockTile();
				else
					t = new Tile(type); // it's a null or release tile
				grid[x][y] = t;
			}
		}
	}

	/**
	 * Gets the current score.
	 * 
	 * @return an integer representing the current score.
	 */
	public int getPoints() {
		return points;
	}

	/**
	 * Adds points to the current score
	 * 
	 * @param points
	 *            the amount of points to be added
	 */
	public void addPoints(int points) {
		this.points += points;
	}

	/**
	 * Sets the current score to zero.
	 */
	public void resetPoints() {
		points = 0;
	}

	/**
	 * @return the object that is used to represent the differnet criteria for
	 *         earning star(s) on this level.
	 */
	public StarCriteria getStarCriteria() {
		return starCriteria;
	}

	/**
	 * @return a two dimensional array that is used to represent the Tiles on
	 *         this appear. The order of the Tiles in this array is important
	 *         for game logic.
	 * 
	 */
	public Tile[][] getGrid() {
		return grid;
	}

	/**
	 * @param grid
	 *            An array used to set the Tiles on the grid.
	 * @see Board#getGrid()
	 */
	public void setGrid(Tile[][] grid) {
		this.grid = grid;
	}

	// TODO do we need this
	public void scrubGrid() {
		GameMode g = template.getGameMode();

		switch (g) {
		case Puzzle:
		case Elimination:
		case Lightning:
			for (int x = 0; x < 9; x++) {
				for (int y = 0; y < 9; y++) {
					TileType type = grid[x][y].getType();
					if (type == TileType.Release || type == TileType.Block) {
						grid[x][y].setType(TileType.Null);
					}
				}
			}
			break;
		case Release:
			break;
		}
	}

	/**
	 * Increases the time passed by 1 second.
	 */
	public void increaseTimePassed() {
		timePassed++;
	}

	/**
	 * Resets the time passed to zero.
	 */
	public void resetTimePassed() {
		timePassed = 0;
	}

	/**
	 * @return an integer corresponding to the amount of moves made
	 */
	public int getMovesMade() {
		return movesMade;
	}

	/**
	 * Increases the amount of moves made by one.
	 */
	public void increaseMovesMade() {
		movesMade++;
	}

	/**
	 * Sets the amount of moves made to zero.
	 */
	public void resetMovesMade() {
		movesMade = 0;
	}

	/**
	 * Indicates if there are any 'empty' Tiles on this Board. Empty Tiles are
	 * denoted by having a null object reference.
	 * <p>
	 * There are only empty Tiles on a Board between discrete states.
	 * Controllers that handle game aspects such as gravity look for them and
	 * fix them between moves.
	 * 
	 * @return true if there are any 'empty' Tiles, false if otherwise.
	 */
	public boolean emptyTilesOnBoard() {
		for (Tile[] r : grid)
			for (Tile t : r)
				if (t == null)
					return true;
		return false;
	}

	/**
	 * Generates a Tile with a random number and multiplier based off of the
	 * board template.
	 * 
	 * @return Tile with a randomized number and multiplier.
	 */
	public Tile getNextTile() {
		Random x = new Random();
		int result = x.nextInt(99) + 1;
		if (result < r1) {
			return getNextTileHelper(1);
		} else if (result <= (r1 + r2)) {
			return getNextTileHelper(2);
		} else if (result <= (r1 + r2 + r3)) {
			return getNextTileHelper(3);
		} else if (result <= (r1 + r2 + r3 + r4)) {
			return getNextTileHelper(4);
		} else if (result <= (r1 + r2 + r3 + r4 + r5)) {
			return getNextTileHelper(5);
		} else if (this instanceof ReleaseBoard
				|| this instanceof EliminationBoard) {
			return getNextTileHelper(x.nextInt(5) + 1);
		} else {
			return new Tile(6, 1);
		}
	}

	/**
	 * Helper function for getNextTile that generates the multiplier for the
	 * tile based off of the board template.
	 * 
	 * @param number
	 *            : Indicates Tile's number value
	 * @return Tile with a randomized number and multiplier.
	 */
	public Tile getNextTileHelper(int number) {
		Random y = new Random();
		int rand = y.nextInt(99) + 1;
		if (rand <= m1) {
			return new Tile(number, 1);
		} else if (rand <= (m1 + m2)) {
			return new Tile(number, 2);
		} else {
			return new Tile(number, 3);
		}
	}

	/**
	 * Gets a board's LevelTemplate.
	 * 
	 * @return LevelTemplate of the board.
	 */
	public LevelTemplate getTemplate() {
		return template;
	}

	/**
	 * Sets a LevelTemplate to a Board.
	 * 
	 * @param template
	 *            used for setting on the board.
	 */
	public void setTemplate(LevelTemplate template) {
		this.template = template;
	}

	/**
	 * Adds a tile's number value to the current running sum.
	 * 
	 * @param n
	 *            : value of recently selected tile
	 */
	public void addTileSum(int n) {
		tileSum += n;
	}

	/**
	 * Resets the tile sum to zero.
	 */
	public void resetTileSum() {
		tileSum = 0;
	}

	/**
	 * Returns the current tile sum of the Board.
	 * 
	 * @return current tile sum
	 */
	public int getTileSum() {
		return tileSum;
	}

	/**
	 * Increase tile count by 1.
	 */
	public void increaseTileCount() {
		tileCount++;
	}

	/**
	 * Reset tile count to zero.
	 */
	public void resetTileCount() {
		tileCount = 0;
	}

	/**
	 * Returns the current tile count.
	 * 
	 * @return current tile count
	 */
	public int getTileCount() {
		return tileCount;
	}

	/**
	 * Deselects every Tile in this Board's grid. This is used when cleaning up
	 * after a Move.
	 */
	public void unselectTiles() {
		for (Tile[] r : grid)
			for (Tile t : r) {
				t.unSelect();
			}
	}

	/**
	 * @param moveType
	 *            the MoveType to be set
	 */
	public void setMoveType(MoveType moveType) {
		this.moveType = moveType;
	}

	/**
	 * @return The kind of operation being performed on this Board
	 */
	public MoveType getMoveType() {
		return moveType;
	}

	/**
	 * @return the x-value from the last selection
	 */
	public int getLastX() {
		return lastX;
	}

	/**
	 * @param lastX
	 *            the new x-value from the latest selection
	 */
	public void setLastX(int lastX) {
		this.lastX = lastX;
	}

	/**
	 * @return the y-value from the last selection
	 */
	public int getLastY() {
		return lastY;
	}

	/**
	 * @param lastX
	 *            the new y-value from the latest selection
	 */
	public void setLastY(int lastY) {
		this.lastY = lastY;
	}

	/**
	 * Sets a flag indicating the mouse has been pressed
	 */
	public void pressMouse() {
		isMousePressed = true;
	}

	/**
	 * Sets a flag indicating the mouse has been released
	 */
	public void releaseMouse() {
		isMousePressed = false;
	}

	/**
	 * @return a flag indicating whether or not the mouse has been pressed
	 */
	public boolean isMousePressed() {
		return isMousePressed;
	}

	/**
	 * @return the move limit
	 */
	public int getMoveLimit() {
		return moveLimit;
	}

	/**
	 * Scrambles the Tiles in the grid.
	 */
	public void resetGrid() {
		for (int x = 0; x < Board.BOARD_LENGTH; x++) {
			for (int y = 0; y < Board.BOARD_WIDTH; y++) {
				Tile t = this.getGrid()[x][y];
				if (t.getType() == TileType.Number) {
					this.getGrid()[x][y] = getNextTile();
				}
			}
		}
	}

	/**
	 * Subclasses can override this function as needed.
	 * 
	 * @return the time limit for this game.
	 */
	public int getTimeLimit() {
		return -1;
	}

	/**
	 * @return the amount of time that has passed since the game has been started.
	 */
	public int getTimePassed() {
		return this.timePassed;
	}

	/**
	 * Functionally resets everything about the level you are playing. This
	 * function is called when the Restart Level button is clicked on.
	 */
	public void resetBoard() {
		Board newBoard = Board.MakeBoardFromTemplate(template, name);
		this.setGrid(newBoard.getGrid());
		resetPoints();
		resetTimePassed();
		resetMovesMade();
		resetTileSum();
		resetTileCount();
		unselectTiles();
	}

	/**
	 * @return a {@link StarRating} for a Board based off of this Board's
	 *         {@link StarCriteria} objects.
	 */
	public StarRating checkCriteria() {
		if (this.points >= this.starCriteria.points3)
			return StarRating.ThreeStars;
		else if (this.points >= this.starCriteria.points2)
			return StarRating.TwoStars;
		else if (this.points >= this.starCriteria.points1)
			return StarRating.OneStar;
		return StarRating.NoStars;
	}

	/**
	 * Removes a Tile at the given location.
	 * 
	 * This function leaves the Board in an inconsistent state.
	 * 
	 * This function may be overridden, <b>however</b> it is the responsibility
	 * of the subclass to call the parent function to ensure all functionality
	 * still occurs.
	 * 
	 * @param x
	 *            the row of the Tile
	 * @param y
	 *            the column of the Tile
	 */
	public void removeTile(int x, int y) {
		grid[x][y] = null;
	}

	public Score getScore() {
		StarRating rating = starCriteria.getStarRating(points);		
		Score finalScore = new Score(points, rating);
		return finalScore;
	}

	public String getName() {
		if (name != null)
			return name;
		else
			return "NULL";
	}

	/**
	 * 
	 * Specific Board implementations must override this method and make it
	 * return true if that variation of SixesWild has been won, and false
	 * otherwise.
	 * 
	 * @return true if a winning condition has been established on this Board.
	 */
	public abstract boolean hasWon();

	/**
	 * Subclasses can override this method in order to set the game into a state
	 * where moves can't be performed.
	 */
	public void stopMovement() {
		return;
	}

	public TileType[][] convertGrid() {
		TileType[][] newGrid;
		newGrid = new TileType[9][9];
		for (int x = 0; x < 9; x++) {
			for (int y = 0; y < 9; y++) {
				TileType type = grid[x][y].getType();
				newGrid[x][y] = type;
			}
		}
		return newGrid;
	}
	
	public boolean getWinFlag() {
		return this.winFlag;
	}
	
	public void setWinFlag(boolean setter) {
		this.winFlag = setter;
	}
	
}

/* OLD BOARD FROM EDITOR */
// package model;
//
//
// public class Board {
// LevelTemplate template;
// Tile[][] grid;
//
// public Board(LevelTemplate template) {
// this.template = template;
// grid = new Tile[9][9];
// TileType[][] gridTemplate = template.getGridTemplate();
// for (int x = 0; x < 9; x++) {
// for (int y = 0; y < 9; y++) {
// TileType type = gridTemplate[x][y];
// Tile t;
// if (type == TileType.Number)
// t = getNextTile();
// else
// t = new Tile(type); // it's a null or release tile
// grid[x][y] = t;
// }
// }
// }
//
// /*@SuppressWarnings("unused")
// // TODO delete this when we are confident we don't need it anymore
// private void insertNullsForTesting() {
// for (int i = 0; i < 3; i++) {
// Random r = new Random();
// int x = r.nextInt(9);
// int y = r.nextInt(9);
// grid[x][y] = null;
// }
// }*/
//
//
// public Tile[][] getGrid() {
// return grid;
// }
//
// public void setGrid(Tile[][] grid) {
// this.grid = grid;
// }
//
// public boolean emptyTilesOnBoard() {
// for (Tile[] r : grid)
// for (Tile t : r)
// if (t == null)
// return true;
// return false;
// }
//
// public Tile getNextTile() {
// // TODO implement this with an actual randomly weighted tile
// return new Tile(Math.random() > 0.5 ? 1 : 2);
// // for now just give us a Tile valued 1 or 2
// }
//
// public LevelTemplate getTemplate() {
// return template;
// }
//
// /* public void setTemplate(LevelTemplate template) {
// this.template = template;
// }*/
//
// public void resetTiles() {
// for (Tile[] r : grid)
// for (Tile t : r) {
// t.unSelect();
// }
// }
//
// public TileType[][] convertGrid() {
// TileType[][] newGrid;
// newGrid = new TileType[9][9];
// for (int x = 0; x < 9; x++) {
// for (int y = 0; y < 9; y++) {
// TileType type = grid[x][y].getType();
// newGrid[x][y] = type;
// }
// }
// return newGrid;
// }
//
// public void scrubGrid() {
// GameMode g = template.getGameMode();
//
// switch(g) {
// case Puzzle:
// case Elimination:
// case Lightning:
// for (int x = 0; x < 9; x++) {
// for (int y = 0; y < 9; y++) {
// TileType type = grid[x][y].getType();
// if(type == TileType.Release || type == TileType.Block) {
// grid[x][y].setType(TileType.Null);
// }
// }
// }
// break;
// case Release:
// break;
// }
//
// }
//
//
// }
